using Unitful
using UnitfulAtomic
using PeriodicTable
using StaticArrays
import Base.position

export AbstractSystem, AbstractAtomicSystem
export SimpleAtom
export BoundaryCondition, DirichletZero, Periodic
export atomic_mass,
    atomic_number,
    atomic_symbol,
    bounding_box,
    element,
    position,
    velocity,
    boundary_conditions,
    periodic_dims
export atomic_property, has_atomic_property, atomic_propertynames
export n_dimensions

velocity(p)::AbstractVector{<:Unitful.Velocity} = missing
position(p)::AbstractVector{<:Unitful.Length} = error("Implement me")

#
# Identifier for boundary conditions per dimension
#
abstract type BoundaryCondition end
struct DirichletZero <: BoundaryCondition end  # Dirichlet zero boundary (i.e. molecular context)
struct Periodic <: BoundaryCondition end  # Periodic BCs


#
# The system type
#     Again readonly.
#

abstract type AbstractSystem{D,ET} end
(bounding_box(::AbstractSystem{D})::SVector{D,SVector{D,<:Unitful.Length}}) where {D} =
    error("Implement me")
(boundary_conditions(::AbstractSystem{D})::SVector{D,BoundaryCondition}) where {D} =
    error("Implement me")

get_periodic(sys::AbstractSystem) =
    [isa(bc, Periodic) for bc in get_boundary_conditions(sys)]

# Note: Can't use ndims, because that is ndims(sys) == 1 (because of AbstractVector interface)
n_dimensions(::AbstractSystem{D}) where {D} = D


# indexing interface
Base.getindex(::AbstractSystem, ::Int) = error("Implement me")
Base.size(::AbstractSystem) = error("Implement me")
Base.length(::AbstractSystem) = error("Implement me")
Base.setindex!(::AbstractSystem, ::Int) = error("AbstractSystem objects are not mutable.")
Base.firstindex(::AbstractSystem) = 1
Base.lastindex(s::AbstractSystem) = length(s)
Base.iterate(S::AbstractSystem, i::Int=1) = (1 <= i <= length(S)) ? (@inbounds S[i], i+1) : nothing

# iteration interface, needed for default broadcast dispatches below to work
Base.iterate(sys::AbstractSystem{D,ET}, state = firstindex(sys)) where {D,ET} =
    state > length(sys) ? nothing : (sys[state], state + 1)

# TODO Support similar, push, ...

# Some implementations might prefer to store data in the System as a flat list and
# expose Atoms as a view. Therefore these functions are needed. Of course this code
# should be autogenerated later on ...
position(sys::AbstractSystem) = position.(sys)    # in Cartesian coordinates!
velocity(sys::AbstractSystem) = velocity.(sys)    # in Cartesian coordinates!
element(sys::AbstractSystem) = element.(sys)

#
# Extra stuff only for Systems composed of atoms
#
const AbstractAtomicSystem{D} = AbstractSystem{D,Element}
atomic_symbol(sys::AbstractAtomicSystem) = atomic_symbol.(sys)
atomic_number(sys::AbstractAtomicSystem) = atomic_number.(sys)
atomic_mass(sys::AbstractAtomicSystem) = atomic_mass.(sys)
atomic_property(sys::AbstractAtomicSystem, property::Symbol)::Vector{Any} =
    atomic_property.(sys, property)
atomic_propertiesnames(sys::AbstractAtomicSystem) = unique(sort(atomic_propertynames.(sys)))

struct SimpleAtom{D}
    position::SVector{D,<:Unitful.Length}
    element::Element
end
SimpleAtom(position, element) = SimpleAtom{length(position)}(position, element)
position(atom::SimpleAtom) = atom.position
element(atom::SimpleAtom) = atom.element

function SimpleAtom(position, symbol::Union{Integer,AbstractString,Symbol,AbstractVector})
    SimpleAtom(position, elements[symbol])
end

# Just to make testing a little easier for now
function Base.show(io::IO, mime::MIME"text/plain", sys::AbstractSystem)
    println(io, "System:")
    println(io, "    BCs:        ", boundary_conditions(sys))
    println(io, "    Box:        ", bounding_box(sys))
    println(io, "    Particles:  ")
    for particle in sys
        Base.show(io, mime, particle)
        println(io)
    end
end
