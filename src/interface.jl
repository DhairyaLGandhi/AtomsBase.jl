using Unitful
using Unitful: Velocity
using UnitfulAtomic
using PeriodicTable

#
# A distinguishable particle, can be anything associated with coordinate
# information (position, velocity, etc.)
# most importantly: Can have any identifier type
#
# IdType:  Type used to identify the particle
#
abstract type AbstractParticle{IdType} end
get_velocity(::AbstractParticle)::AbstractVector{<: Velocity} = missing
get_position(::AbstractParticle)::AbstractVector{<: Length}   = error("Implement me")
function get_identifier(::AbstractParticle{IdType})::IdType where {IdType}
    error("Implement me")
end


#
# The atom type itself
#     - The atom interface is read-only (to allow as simple as possible implementation)
#       Writability may be supported in derived or concrete types.
#     - The inferface is only in Cartesian coordinates.
#     - Has atom-specific defaults (i.e. assumes every entity represents an atom or ion)
#
abstract type AbstractAtom <: AbstractParticle{Symbol} end
get_identifier(atom::AbstractAtom) = get_atomic_symbol(atom)

# Extracting things from PeriodicTable automatically:
#     - Only get_identifier needs to be implemented, but many features obtained from PeriodicTable
get_atomic_symbol(::AbstractAtom)     = error("Implement me")
get_atomic_number(atom::AbstractAtom) = elements[get_atomic_symbol(atom)].number
get_atomic_mass(atom::AbstractAtom)   = elements[get_atomic_symbol(atom)].atomic_mass

# Custom atomic properties:
get_atomic_property(::AbstractAtom, ::Symbol, default=missing) = default
has_atomic_property(atom::AbstractAtom, property::Symbol) = !ismissing(get_atomic_property(atom, property))
atomic_propertynames(::AbstractAtom) = Symbol[]

#
# Identifier for boundary conditions per dimension
#
abstract type BoundaryCondition end
struct Dirichlet <: BoundaryCondition end  # Dirichlet zero boundary (i.e. molecular context)
struct Periodic  <: BoundaryCondition end  # Periodic BCs


#
# The system type
#     Again readonly.
#
abstract type AbstractSystem{AT <: AbstractParticle} <: AbstractVector{AT} end
get_cell(::AbstractSystem)::Vector{<:AbstractVector} = error("Implement me")
get_boundary_conditions(::AbstractSystem)::AbstractVector{BoundaryCondition} = error("Implement me")
get_periodic(sys::AbstractSystem) = [isa(bc, Periodic) for bc in get_boundary_conditions(sys)]

getindex(::AbstractSystem, ::Int)  = error("Implement me")
size(::AbstractSystem)             = error("Implement me")
setindex!(::AbstractSystem, ::Int) = error("AbstractSystem objects are not mutable.")

# TODO Support similar, push, ...

# Some implementations might prefer to store data in the System as a flat list and
# expose Atoms as a view. Therefore these functions are needed. Of course this code
# should be autogenerated later on ...
get_position(sys::AbstractSystem)   = get_position.(sys)    # in Cartesian coordinates!
get_velocity(sys::AbstractSystem)   = get_velocity.(sys)    # in Cartesian coordinates!
get_identifier(sys::AbstractSystem) = get_identifier.(sys)

#
# Extra stuff only for Systems composed of atoms
#
get_atomic_symbol(sys::AbstractSystem{<: AbstractAtom}) = get_atomic_symbol.(sys)
get_atomic_number(sys::AbstractSystem{<: AbstractAtom}) = get_atomic_number.(sys)
get_atomic_mass(sys::AbstractSystem{<: AbstractAtom})   = get_atomic_mass.(sys)
get_atomic_property(sys::AbstractSystem{<: AbstractAtom}, property::Symbol)::Vector{Any} = get_atomic_property.(sys, property)
atomic_propertiesnames(sys::AbstractSystem{<: AbstractAtom}) = unique(sort(atomic_propertynames.(sys)))
