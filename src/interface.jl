using Unitful
using UnitfulAtomic
using PeriodicTable

export AbstractParticle, AbstractAtom, AbstractSystem
export BoundaryCondition, DirichletZero, Periodic
export get_atomic_mass, get_atomic_number, get_atomic_symbol,
    get_cell, get_identifier, get_position, get_velocity,
    get_boundary_conditions, get_periodic
export get_atomic_property, has_atomic_property, atomic_propertynames
export n_dimensions

#
# A distinguishable particle, can be anything associated with coordinate
# information (position, velocity, etc.)
# most importantly: Can have any identifier type
#
# IdType:  Type used to identify the particle
#
abstract type AbstractParticle{IdType} end
get_velocity(::AbstractParticle)::AbstractVector{<: Unitful.Velocity} = missing
get_position(::AbstractParticle)::AbstractVector{<: Unitful.Length}   = error("Implement me")
function get_identifier(::AbstractParticle{IdType})::IdType where {IdType}
    error("Implement me")
end


#
# The atom type itself
#     - The atom interface is read-only (to allow as simple as possible implementation)
#       Writability may be supported in derived or concrete types.
#     - The inferface is only in Cartesian coordinates.
#     - Has atom-specific defaults (i.e. assumes every entity represents an atom or ion)
#
abstract type AbstractAtom <: AbstractParticle{Symbol} end
get_identifier(atom::AbstractAtom) = get_atomic_symbol(atom)

# Extracting things from PeriodicTable automatically:
#     - Only get_identifier needs to be implemented, but many features obtained from PeriodicTable
get_atomic_symbol(::AbstractAtom)     = error("Implement me")
get_atomic_number(atom::AbstractAtom) = elements[get_atomic_symbol(atom)].number
get_atomic_mass(atom::AbstractAtom)   = elements[get_atomic_symbol(atom)].atomic_mass

# Custom atomic properties:
get_atomic_property(::AbstractAtom, ::Symbol, default=missing) = default
has_atomic_property(atom::AbstractAtom, property::Symbol) = !ismissing(get_atomic_property(atom, property))
atomic_propertynames(::AbstractAtom) = Symbol[]

#
# Identifier for boundary conditions per dimension
#
abstract type BoundaryCondition end
struct DirichletZero <: BoundaryCondition end  # Dirichlet zero boundary (i.e. molecular context)
struct Periodic  <: BoundaryCondition end      # Periodic BCs


#
# The system type
#     Again readonly.
#
abstract type AbstractSystem{AT <: AbstractParticle} <: AbstractVector{AT} end
get_cell(::AbstractSystem)::Vector{<:AbstractVector} = error("Implement me")
get_boundary_conditions(::AbstractSystem)::AbstractVector{BoundaryCondition} = error("Implement me")
get_periodic(sys::AbstractSystem) = [isa(bc, Periodic) for bc in get_boundary_conditions(sys)]

# Note: Can't use ndims, because that is ndims(sys) == 1 (because of AbstractVector interface)
n_dimensions(sys::AbstractSystem) = length(get_boundary_conditions(sys))

Base.getindex(::AbstractSystem, ::Int)  = error("Implement me")
Base.size(::AbstractSystem)             = error("Implement me")
Base.setindex!(::AbstractSystem, ::Int) = error("AbstractSystem objects are not mutable.")

# TODO Support similar, push, ...

# Some implementations might prefer to store data in the System as a flat list and
# expose Atoms as a view. Therefore these functions are needed. Of course this code
# should be autogenerated later on ...
get_position(sys::AbstractSystem)   = get_position.(sys)    # in Cartesian coordinates!
get_velocity(sys::AbstractSystem)   = get_velocity.(sys)    # in Cartesian coordinates!
get_identifier(sys::AbstractSystem) = get_identifier.(sys)

#
# Extra stuff only for Systems composed of atoms
#
get_atomic_symbol(sys::AbstractSystem{<: AbstractAtom}) = get_atomic_symbol.(sys)
get_atomic_number(sys::AbstractSystem{<: AbstractAtom}) = get_atomic_number.(sys)
get_atomic_mass(sys::AbstractSystem{<: AbstractAtom})   = get_atomic_mass.(sys)
get_atomic_property(sys::AbstractSystem{<: AbstractAtom}, property::Symbol)::Vector{Any} = get_atomic_property.(sys, property)
atomic_propertiesnames(sys::AbstractSystem{<: AbstractAtom}) = unique(sort(atomic_propertynames.(sys)))

# Just to make testing a little easier for now
function Base.show(io::IO, ::MIME"text/plain", part::AbstractParticle)
    print(io, "Particle (", get_identifier(part), ")  @ ", get_position(part))
end
function Base.show(io::IO, mime::MIME"text/plain", sys::AbstractSystem)
    println(io, "System:")
    println(io, "    BCs:        ", get_boundary_conditions(sys))
    println(io, "    Cell:       ", get_cell(sys))
    println(io, "    Particles:  ")
    for particle in sys
        Base.show(io, mime, particle)
        println(io)
    end
end
