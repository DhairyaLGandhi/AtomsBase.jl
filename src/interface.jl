using Unitful
using UnitfulAtomic
using PeriodicTable
using StaticArrays
import Base.position

export AbstractSystem, AbstractAtomicSystem
export StaticAtom
export BoundaryCondition, DirichletZero, Periodic
export atomic_mass,
    atomic_number,
    atomic_symbol,
    bounding_box,
    species,
    position,
    velocity,
    boundary_conditions,
    periodic_dims
export atomic_property, has_atomic_property, atomic_propertynames
export n_dimensions

velocity(p)::Union{Unitful.Velocity,Missing} = missing
position(p)::Unitful.Length = error("Implement me")
species(p) = error("Implement me")

#
# Identifier for boundary conditions per dimension
#
abstract type BoundaryCondition end
struct DirichletZero <: BoundaryCondition end  # Dirichlet zero boundary (i.e. molecular context)
struct Periodic <: BoundaryCondition end  # Periodic BCs


#
# The system type
#     Again readonly.
#

abstract type AbstractSystem{D,S} end
(bounding_box(::AbstractSystem{D})::SVector{D,SVector{D,<:Unitful.Length}}) where {D} =
    error("Implement me")
(boundary_conditions(::AbstractSystem{D})::SVector{D,BoundaryCondition}) where {D} =
    error("Implement me")

get_periodic(sys::AbstractSystem) =
    [isa(bc, Periodic) for bc in get_boundary_conditions(sys)]

# Note: Can't use ndims, because that is ndims(sys) == 1 (because of indexing interface)
n_dimensions(::AbstractSystem{D}) where {D} = D


# indexing and iteration interface
Base.getindex(::AbstractSystem, ::Int) = error("Implement me")
Base.length(::AbstractSystem) = error("Implement me")
Base.size(s::AbstractSystem) = (length(s),)
Base.setindex!(::AbstractSystem, ::Int) = error("AbstractSystem objects are not mutable.")
Base.firstindex(::AbstractSystem) = 1
Base.lastindex(s::AbstractSystem) = length(s)
Base.iterate(S::AbstractSystem, state=firstindex(S)) = (firstindex(S) <= i <= length(S)) ? (@inbounds S[i], i+1) : nothing

# TODO Support similar, push, ...

# Some implementations might prefer to store data in the System as a flat list and
# expose Atoms as a view. Therefore these functions are needed. Of course this code
# should be autogenerated later on ...
position(sys::AbstractSystem) = position.(sys)    # in Cartesian coordinates!
velocity(sys::AbstractSystem) = velocity.(sys)    # in Cartesian coordinates!
species(sys::AbstractSystem) = species.(sys)

#
# Extra stuff only for Systems composed of atoms
#
const AbstractAtomicSystem{D} = AbstractSystem{D,Element}
atomic_symbol(sys::AbstractAtomicSystem) = atomic_symbol.(sys)
atomic_number(sys::AbstractAtomicSystem) = atomic_number.(sys)
atomic_mass(sys::AbstractAtomicSystem) = atomic_mass.(sys)
atomic_property(sys::AbstractAtomicSystem, property::Symbol)::Vector{Any} =
    atomic_property.(sys, property)
atomic_propertiesnames(sys::AbstractAtomicSystem) = unique(sort(atomic_propertynames.(sys)))

struct StaticAtom{D,L<:Unitful.Length}
    position::SVector{D,L}
    element::Element
end
StaticAtom(position, element) = StaticAtom{length(position)}(position, element)
position(atom::StaticAtom) = atom.position
species(atom::StaticAtom) = atom.element

function StaticAtom(position, symbol::Union{Integer,AbstractString,Symbol,AbstractVector})
    StaticAtom(position, elements[symbol])
end

# Just to make testing a little easier for now
function Base.show(io::IO, mime::MIME"text/plain", sys::AbstractSystem)
    println(io, "System:")
    println(io, "    BCs:        ", boundary_conditions(sys))
    println(io, "    Box:        ", bounding_box(sys))
    println(io, "    Particles:  ")
    for particle in sys
        Base.show(io, mime, particle)
        println(io)
    end
end
